<!doctype html>
<html lang="ml">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Malayalam Template - Reliable DOCX Download</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- JSZip for building .docx (zip) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <style>
    body {
      font-family: "Manjari", "Noto Sans Malayalam", system-ui, sans-serif;
      background-color: #f8fafc;
      color: #1e293b;
    }
    .card {
      max-width: 1000px;
      margin: 30px auto;
      background: #fff;
      padding: 25px 30px;
      border-radius: 16px;
      box-shadow: 0 6px 30px rgba(0,0,0,0.06);
    }
    .template {
      white-space: pre-wrap;
      word-break: break-word;
      background: #f1f5f9;
      padding: 14px;
      border-radius: 10px;
      border: 1px solid #e2e8f0;
      font-size: 1rem;
    }
    textarea {
      width: 100%;
      border: 1px solid #cbd5e1;
      padding: 10px;
      border-radius: 8px;
      resize: none;
      font-size: 1rem;
    }
    button { cursor: pointer; }
  </style>
</head>
<body>
  <div class="card">
    <h1 class="text-3xl font-semibold text-indigo-700 mb-2">For Kavya C J CRP</h1>
    <p class="text-gray-600 mb-4">
      Type in <b>Manglish</b> (Roman Malayalam). It will automatically convert to Malayalam after a short pause or when you press space.<br>
      <b>Numbers and units (like 2025, 3km, 10.5)</b> will remain as they are.
    </p>

    <h2 class="text-lg font-semibold mb-2">Malayalam Template</h2>
    <pre id="templatePreview" class="template text-lg">
_________________________ എന്ന ആളുകളുടെ _______________ സർവ്വേ നമ്പറിൽ പെട്ട __ ആർ ___ സ്ക്വേ .മീ സ്ഥലം പരിശോധിച്ചതിൽ ടി സ്ഥലത്തിന്റെ സമീപത്തു നെൽകൃഷി ചെയ്യുന്ന പ്രദേശം ഇല്ല. സ്ഥലത്തു ____ വർഷം പ്രായമുള്ള ___ തെങ്ങ്, പ്രദേശത്തിൻ്റെ വടക്ക് __________, തെക്ക് ____________, കിഴക്കു _____________, പടിഞ്ഞാറ് ____________________. സ്ഥലം 2008 നെൽവയൽ/തണ്ണീർത്തട സംരക്ഷണ നിയമപ്രകാരം നെൽവയൽ/തണ്ണീർശടം എന്നിവയുടെ നിർവചനത്തിൽ വരുന്നതല്ല എന്ന് അനുമാനിക്കാവുന്നതാണ്. ആയതിനാൽ മേൽപ്പറഞ്ഞ സ്ഥലം ഡാറ്റ ബാങ്കിൽ നിന്നും ഒഴിവാക്കാവുന്നതാണ്.
    </pre>

    <h2 class="text-lg font-semibold mt-6 mb-2">Fill the blanks (in Manglish)</h2>
    <div id="inputsArea" class="space-y-4"></div>

    <div class="flex gap-2 mt-6">
      <button id="copyBtn" class="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700">Copy</button>
      <button id="downloadBtn" class="px-4 py-2 border border-indigo-600 text-indigo-600 rounded hover:bg-indigo-50">Download DOCX</button>
      <button id="resetBtn" class="px-4 py-2 bg-gray-100 text-gray-700 rounded hover:bg-gray-200">Reset</button>
    </div>

    <h2 class="text-lg font-semibold mt-6 mb-2">Final Malayalam Sentence</h2>
    <div id="finalOutput" class="rounded p-4 bg-gray-50 border border-gray-200 min-h-[200px] text-lg"></div>
  </div>

<script>
/* --- Template & blanks setup (unchanged) --- */
const template = document.getElementById("templatePreview").textContent;
const blanks = [...template.matchAll(/_+/g)];
const inputsArea = document.getElementById("inputsArea");
const finalOutput = document.getElementById("finalOutput");

const blankLabels = [
  "Name",
  "Survey Number",
  "Aar",
  "Sq. Mtr",
  "Varsham Prayam",
  "Coconut No",
  "North",
  "South",
  "East",
  "West"
];

blanks.forEach((b, i) => {
  const div = document.createElement("div");
  const label = blankLabels[i] || `Blank ${i+1}`;
  div.innerHTML = `
    <label class="block text-sm text-gray-700 mb-1">${label}</label>
    <textarea id="input_${i}" rows="1" placeholder="Type in Manglish..."></textarea>
    <div id="preview_${i}" class="text-gray-500 text-sm mt-1"></div>
  `;
  inputsArea.appendChild(div);
});

/* --- Transliteration logic (kept same) --- */
document.querySelectorAll("textarea").forEach((t, i) => {
  let timeout;
  t.addEventListener("input", (e) => {
    clearTimeout(timeout);
    if (e.data === " ") transliterateLastWord(t, i);
    timeout = setTimeout(() => transliterateLastWord(t, i), 3000);
    // live preview
    const preview = document.getElementById(`preview_${i}`);
    if (preview) preview.textContent = t.value;
  });
});

async function transliterateLastWord(field, index) {
  const text = field.value;
  const words = text.split(/\s+/);
  const lastWord = words[words.length - 1];
  if (!lastWord || /^[0-9.,+-/]+$/.test(lastWord)) {
    updateOutput();
    return;
  }
  const url = `https://inputtools.google.com/request?text=${encodeURIComponent(lastWord)}&itc=ml-t-i0-und&num=1&cp=0&cs=1&ie=utf-8&oe=utf-8`;
  try {
    const res = await fetch(url);
    const data = await res.json();
    if (data[0] === "SUCCESS" && data[1]?.[0]?.[1]?.[0]) {
      words[words.length - 1] = data[1][0][1][0];
      field.value = words.join(" ");
      const preview = document.getElementById(`preview_${index}`);
      if (preview) preview.textContent = field.value;
    }
  } catch (err) {
    console.error("Transliteration error:", err);
  }
  updateOutput();
}

function updateOutput() {
  let out = template;
  inputsArea.querySelectorAll("textarea").forEach(input => {
    out = out.replace(/_+/, input.value.trim());
  });
  finalOutput.textContent = out;
}

/* Copy & Reset (unchanged) */
document.getElementById("copyBtn").onclick = async () => {
  const text = finalOutput.textContent.trim();
  if (!text) return alert("No text to copy.");
  await navigator.clipboard.writeText(text);
  alert("Copied ✅");
};

document.getElementById("resetBtn").onclick = () => {
  document.querySelectorAll("textarea").forEach(t => {
    t.value = "";
    const preview = document.getElementById(`preview_${t.id.split("_")[1]}`);
    if (preview) preview.textContent = "";
  });
  finalOutput.textContent = "";
};

/* ---------------------------
   DOCX creation using JSZip
   --------------------------- */

/*
 Minimal required files to create a valid DOCX:
 - [Content_Types].xml
 - _rels/.rels
 - docProps/core.xml
 - word/document.xml
 - word/styles.xml (simple)
 We'll create those and zip them with JSZip, then download as .docx
*/

function escapeXml(unsafe) {
  if (!unsafe) return "";
  return unsafe.replace(/&/g, "&amp;")
               .replace(/</g, "&lt;")
               .replace(/>/g, "&gt;")
               .replace(/"/g, "&quot;")
               .replace(/'/g, "&apos;");
}

function buildDocxXml(text) {
  // Split input into paragraphs on newline, produce <w:p> per paragraph
  const paragraphs = text.split(/\r?\n/).map(p => `<w:p><w:r><w:t xml:space="preserve">${escapeXml(p)}</w:t></w:r></w:p>`).join("");
  return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:wpc="http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas"
  xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
  xmlns:o="urn:schemas-microsoft-com:office:office"
  xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"
  xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
  xmlns:v="urn:schemas-microsoft-com:vml"
  xmlns:wp14="http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing"
  xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing"
  xmlns:w10="urn:schemas-microsoft-com:office:word"
  xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
  xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml"
  xmlns:wpg="http://schemas.microsoft.com/office/word/2010/wordprocessingGroup"
  xmlns:wpi="http://schemas.microsoft.com/office/word/2010/wordprocessingInk"
  xmlns:wne="http://schemas.microsoft.com/office/word/2006/wordml"
  xmlns:wps="http://schemas.microsoft.com/office/word/2010/wordprocessingShape"
  mc:Ignorable="w14 wp14">
  <w:body>
    ${paragraphs}
    <w:sectPr>
      <w:pgSz w:w="11906" w:h="16838"/>
      <w:pgMar w:top="1440" w:right="1440" w:bottom="1440" w:left="1440" w:header="708" w:footer="708" w:gutter="0"/>
      <w:cols w:space="708"/>
      <w:docGrid w:linePitch="360"/>
    </w:sectPr>
  </w:body>
</w:document>`;
}

const contentTypes = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
  <Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>
  <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>
</Types>`;

const relsRels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
  <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>
</Relationships>`;

function coreXml() {
  const now = new Date().toISOString();
  return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" 
  xmlns:dc="http://purl.org/dc/elements/1.1/" 
  xmlns:dcterms="http://purl.org/dc/terms/" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <dc:creator>Generated</dc:creator>
  <cp:lastModifiedBy>Generated</cp:lastModifiedBy>
  <dcterms:created xsi:type="dcterms:W3CDTF">${now}</dcterms:created>
  <dcterms:modified xsi:type="dcterms:W3CDTF">${now}</dcterms:modified>
</cp:coreProperties>`;
}

const stylesXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:styles xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:style w:type="paragraph" w:default="1" w:styleId="Normal">
    <w:name w:val="Normal"/>
    <w:rPr/>
  </w:style>
</w:styles>`;

/* Download handler builds the zip and triggers download */
document.getElementById("downloadBtn").onclick = async () => {
  const text = finalOutput.textContent.trim();
  if (!text) return alert("No text to download.");

  try {
    const zip = new JSZip();

    // Required structure
    zip.file("[Content_Types].xml", contentTypes);
    zip.folder("_rels").file(".rels", relsRels);
    zip.folder("docProps").file("core.xml", coreXml());
    zip.folder("word").file("document.xml", buildDocxXml(text));
    zip.folder("word").file("styles.xml", stylesXml);

    const blob = await zip.generateAsync({ type: "blob" });
    // set proper mime for docx
    const docxBlob = new Blob([blob], { type: "application/vnd.openxmlformats-officedocument.wordprocessingml.document" });

    const a = document.createElement("a");
    a.href = URL.createObjectURL(docxBlob);
    a.download = "Malayalam_Converted.docx";
    a.click();
    URL.revokeObjectURL(a.href);
  } catch (err) {
    console.error("DOCX generation failed:", err);
    alert("DOCX generation failed. See console for details.");
  }
};
</script>
</body>
</html>